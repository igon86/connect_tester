# this script would take a folder generated by connect and produce a qsf file for quartus for synthesys
# it also copy the generated files in the parent directory of the rtl code so it can be opered in Quartus
# notice that the first parameter (folder where CONNECT RTL reside) is not used to read RTL rather to
# write the final qsf file of the project
import sys
import os
import shutil

in_ports = ["EN_send_ports_{0}_getNonFullVCs","EN_send_ports_{0}_putFlit","send_ports_{0}_getNonFullVCs","send_ports_{0}_putFlit_flit_in"]
out_ports = ["EN_recv_ports_{0}_getFlit","EN_recv_ports_{0}_putNonFullVCs","recv_ports_{0}_getFlit","recv_ports_{0}_putNonFullVCs_nonFullVCs","recv_ports_info_{0}_getRecvPortID"]

# this is the quartus project file it contains no useful information except for the name of the top entity
connect_qpf_path = "./connect.qpf"
# this is the executable to run for synthesis/placeadnroute/timing
syn_script = "./execute_me"

if len(sys.argv) != 4:
    print >> sys.stderr, "Usage: python assignments.py <connect folder> <number of inputs> <number of outputs>"
else:
    # first this guy prepare the qsf with all the juicy stuff for quartus
    with open('connect_base','r') as f, open('mkNetworkSimple.qsf','w') as g:
        assert os.path.isdir(sys.argv[1])
        num_in = int(sys.argv[2])
        num_out = int(sys.argv[3])
        print "Network to process has {0} inputs and {1} outputs".format(num_in, num_out)
        for line in f:
            g.write(line)

        for i in xrange(num_in):
            for pattern in in_ports:
                port = pattern.format(i)
                g.write( "set_instance_assignment -name VIRTUAL_PIN ON -to {0}\n".format(port))
        for i in xrange(num_out):
            for pattern in out_ports:
                port = pattern.format(i)
                g.write( "set_instance_assignment -name VIRTUAL_PIN ON -to {0}\n".format(port))

        for stuff in os.listdir(sys.argv[1]):
            #print stuff
            if os.path.isfile(os.path.join(sys.argv[1],stuff)):
                if stuff.endswith('.hex'):
                    g.write( "set_global_assignment -name HEX_FILE {0}\n".format(os.path.join("build",stuff)) )
                elif stuff.endswith('.v'):
                    g.write( "set_global_assignment -name VERILOG_FILE {0}\n".format(os.path.join("build",stuff)) )


    #parent_dir = os.pardir(sys.argv[1])
    parent_dir = os.path.abspath(os.path.join(sys.argv[1],os.pardir))
    print "I am going to copy the generated quartus proj files:\n{0} and \n{1} in \n{2}".format(os.path.abspath("./mkNetworkSimple.qsf"),os.path.abspath(connect_qpf_path),os.path.abspath(parent_dir))
    ok = raw_input("Is that ok? [y/n]")
    if ok == 'y':
        assert os.path.isfile(connect_qpf_path) , "Path parameter for the qpf file is incorrect {0}".format(connect_qpf_path)
        assert os.path.isfile("./mkNetworkSimple.qsf") 
        assert os.path.isdir(parent_dir)
        shutil.copyfile("./mkNetworkSimple.qsf",os.path.join(parent_dir,"./mkNetworkSimple.qsf"))
        shutil.copyfile(connect_qpf_path,os.path.join(parent_dir,"./connect.qpf"))
        shutil.copyfile(syn_script,os.path.join(parent_dir,"./execute_me"))
        os.chmod(os.path.join(parent_dir,"./execute_me"),0744) #make it executable
        print "Everything copied succesfully, you can open the Quartus proj in {0}".format(os.path.abspath(parent_dir))
